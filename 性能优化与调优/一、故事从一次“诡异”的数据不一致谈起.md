### 一、故事从一次“诡异”的数据不一致谈起

几年前，我们的 EDC 系统发生过一次线上问题。研究监察员（CRA）在核查一个研究中心的受试者数据时，发现系统生成的核查报告里，受试者的“严重不良事件”数量前后两次查询结果不一致。第一次查询是 5 例，第二次变成了 6 例。

经过排查，我们发现在 CRA 生成报告的间隙，该中心的研究护士正好录入并提交了一例新的严重不良事件。CRA 的两次查询操作，恰好跨越了这次数据写入。这就是典型的并发问题——**幻读**。

这个小小的事故，让我们团队对数据库事务隔离级别的理解和应用，进行了一次彻底的复盘。如果当时我们为这个报表查询的事务设置了合适的隔离级别，这个问题就完全可以避免。

### 二、事务隔离：给并发操作排排坐，定规矩

数据库就像一个公共的账本，很多人（程序）会同时读写。为了防止大家把账本写乱，数据库设计了事务（Transaction）这个机制。一个事务，就是一系列操作的集合，要么全部成功，要么全部失败，这就是**原子性（Atomicity）**。

但光有原子性还不够，当多个事务同时运行时，它们之间该如何“相处”？谁能看到谁的数据？谁的操作会影响谁？这就是**隔离性（Isolation）** 要解决的问题。隔离级别，就是数据库为我们提供的、用来定义事务之间“社交距离”的规则。

SQL 标准定义了四个隔离级别，从低到高分别是：

1.  **读未提交 (Read Uncommitted)**
2.  **读已提交 (Read Committed)**
3.  **可重复读 (Repeatable Read)**
4.  **可串行化 (Serializable)**

级别越高，隔离得越彻底，数据一致性越强，但通常也意味着牺牲了更多的并发性能。下面，我将结合我们的业务场景，逐一剖析这四个级别。

### 三、隔离级别实战解析与 Go 代码实现

在 Go 中，我们通常使用 `database/sql` 包来处理数据库交互。要开启一个带特定隔离级别的事务，你需要用 `db.BeginTx` 方法。

#### 1. 读未提交 (Read Uncommitted)：绝对要避免的“危险关系”

*   **含义**：一个事务可以看到其他事务**还未提交**的修改。
*   **并发问题**：会产生**脏读（Dirty Read）**。
*   **临床场景类比**：这就像一个实习医生看到了主治医生在电子病历里临时写下的一个初步诊断，但这个诊断还没经过最终确认。主治医生后来发现搞错了，删掉了这个诊断。如果实习医生已经根据这个“脏”数据去开了药，后果不堪设想。
*   **我的实践**：在我们的所有医疗相关系统中，**这个级别是禁用的**。数据的准确性永远是第一位的，它带来的性能提升完全不值得我们去冒数据错误的风险。

#### 2. 读已提交 (Read Committed)：最常用的“君子之交”

*   **含义**：一个事务只能看到其他事务**已经提交**的修改。
*   **解决了什么**：避免了脏读。
*   **还存在什么问题**：会产生**不可重复读（Non-repeatable Read）** 和**幻读（Phantom Read）**。
*   **临床场景类比**：
    *   **不可重复读**：一个药剂师正在核对某个患者的用药清单（事务开始）。他第一次看，某个药品的剂量是 50mg。此时，医生修改了医嘱并将剂量改为 100mg（另一事务提交）。药剂师再次核对清单（同一事务内），发现剂量变成了 100mg。在同一次核对工作中，同一个数据变了，这就是不可重复读。
    *   **幻读**：就像文章开头我们遇到的 CRA 报表问题。
*   **我的实践**：这是很多数据库（如 PostgreSQL, SQL Server）的默认级别。在我们系统中，对于一些常规的数据展示页面，比如查看临床试验项目列表、受试者列表等，用这个级别是合适的。用户刷新页面看到最新的、已提交的数据，是符合预期的。

**Go (go-zero) 代码示例：**

假设我们有一个`project-api`服务，用于获取项目信息。在`logic`层，我们可以这样写一个使用“读已提交”的查询逻辑。

```go
// internal/logic/getprojectlogic.go
package logic

import (
	"context"
	"database/sql"

	"your-project/internal/svc"
	"your-project/internal/types"

	"github.com/zeromicro/go-zero/core/logx"
)

type GetProjectLogic struct {
	logx.Logger
	ctx    context.Context
	svcCtx *svc.ServiceContext
}

// ... NewGetProjectLogic and other methods

func (l *GetProjectLogic) GetProject(req *types.GetProjectReq) (*types.Project, error) {
	// 对于常规查询，可以直接使用 svcCtx.DB，它会使用数据库的默认隔离级别
	// 如果需要显式指定 Read Committed
	tx, err := l.svcCtx.DB.BeginTx(l.ctx, &sql.TxOptions{Isolation: sql.LevelReadCommitted})
	if err != nil {
		return nil, err
	}
	defer tx.Rollback() // 保证事务在出错时回滚

	var project types.Project
	// 在事务中执行查询
	err = tx.QueryRowContext(l.ctx, "SELECT id, name, status FROM projects WHERE id = ?", req.ID).
		Scan(&project.ID, &project.Name, &project.Status)
	if err != nil {
		return nil, err
	}
	
	// 查询成功，提交事务
	if err := tx.Commit(); err != nil {
		return nil, err
	}

	return &project, nil
}
```

#### 3. 可重复读 (Repeatable Read)：我们项目中的“定心丸”

*   **含义**：在一个事务开始后，无论它执行多少次相同的查询，结果都是一样的。其他事务的修改或新增在该事务结束前对它都是不可见的。
*   **解决了什么**：避免了脏读、不可重复读。
*   **还存在什么问题**：标准 SQL 定义下，仍然会产生幻读。但 **MySQL 的 InnoDB 引擎通过多版本并发控制（MVCC）和间隙锁（Gap Lock）技术，在“可重复读”级别下就解决了幻读问题**。这也是为什么它能成为 MySQL 默认级别的原因。
*   **临床场景类比**：文章开头提到的 CRA 生成核查报告的场景，就必须使用这个级别。一旦 CRA 开始生成报告（事务开始），系统就应该给他一个当时数据状态的“快照”。无论这期间别人怎么增删改，都不会影响他这份报告的数据一致性。
*   **我的实践**：这是我们系统中**最核心、最常用**的事务级别。所有涉及多步操作、需要保证数据在操作期间不被修改的业务，比如：受试者访视数据提交、药品库存的计算与分发、生成关键性的统计报告等，我们都会显式地使用 `Repeatable Read`。

**Go (go-zero) 代码示例：**

假设我们有一个`edc-api`服务，用于提交一份包含多个检查项的 CRF (病例报告表) 数据。

```go
// internal/logic/submitcrflogic.go
package logic

import (
    "context"
    "database/sql"

    "your-project/internal/svc"
    "your-project/internal/types"

    "github.com/zeromicro/go-zero/core/logx"
    "github.com/zeromicro/go-zero/core/mr" // 使用 map-reduce 并行处理
)

// ...

func (l *SubmitCRFLogic) SubmitCRF(req *types.SubmitCRFReq) error {
	// 开启可重复读事务，这是保证数据一致性的关键
	tx, err := l.svcCtx.DB.BeginTx(l.ctx, &sql.TxOptions{Isolation: sql.LevelRepeatableRead})
	if err != nil {
		return err
	}
	// 使用 defer-recover 机制确保事务最终会被处理
	defer func() {
		if p := recover(); p != nil {
			_ = tx.Rollback()
			panic(p) // re-panic after Rollback
		} else if err != nil {
			_ = tx.Rollback() // err is non-nil; don't change it
		} else {
			err = tx.Commit() // if Commit returns error, it will be returned
		}
	}()

	// 1. 检查受试者状态是否允许提交
	var subjectStatus string
	err = tx.QueryRowContext(l.ctx, "SELECT status FROM subjects WHERE id = ? FOR UPDATE", req.SubjectID).Scan(&subjectStatus)
	if err != nil || subjectStatus != "enrolled" {
		logx.Errorf("subject %d status check failed, status: %s", req.SubjectID, subjectStatus)
		return errors.New("invalid subject status")
	}

	// 2. 并发写入多个检查项数据
	// 使用 go-zero 的 mr.Finish 来并发执行，任何一个错误都会导致整体失败
	err = mr.Finish(func() error {
		for _, item := range req.Items {
			_, err := tx.ExecContext(l.ctx, "INSERT INTO crf_items (subject_id, item_code, value) VALUES (?, ?, ?)", req.SubjectID, item.Code, item.Value)
			if err != nil {
				return err
			}
		}
		return nil
	})
	if err != nil {
		// 错误已在 defer 中处理回滚，这里直接返回
		return err
	}

	// 3. 更新 CRF 的提交状态
	_, err = tx.ExecContext(l.ctx, "UPDATE crfs SET status = 'submitted' WHERE id = ?", req.CRFID)
	
	// defer 中的 tx.Commit() 会在这里之后执行
	return err
}
```
> **关键细节**：在 `SELECT ... FOR UPDATE` 中，我们使用了排他锁。这在 `Repeatable Read` 级别下，能确保在整个事务期间，没有其他事务可以修改这条受试者记录，为我们的后续操作提供了最强的保障。

#### 4. 可串行化 (Serializable)：终极武器，慎用！

*   **含义**：最高的隔离级别。它强制事务串行执行，一个接一个，完全避免了并发问题。
*   **解决了什么**：脏读、不可重复读、幻读，所有并发问题都解决了。
*   **代价是什么**：性能极差。因为它基本上把并发环境变成了单线程环境。
*   **临床场景类比**：在我们的“临床试验机构项目管理系统”中，有一个场景是中心化的、稀缺的临床研究资源（如特定的昂贵检查设备）的预约。当两个研究团队同时预约最后的一个时间段时，我们必须确保只有一个能成功。这种场景下，数据的绝对一致性高于一切，性能可以暂时让步。
*   **我的实践**：**极少使用**。只有在并发冲突概率非常高，且数据一致性要求极为苛刻的“秒杀”类场景才会考虑。在绝大多数情况下，`Repeatable Read` 加上适当的锁机制已经足够健壮。

### 四、我的架构师心得与选型建议

面对事务隔离级别，我的建议是：

1.  **忘记 `Read Uncommitted`**：除非你在做一些非关键数据的、允许巨大误差的统计，否则不要碰它。
2.  **从 `Read Committed` 或 `Repeatable Read` 开始**：了解你所使用数据库的默认隔离级别。MySQL 默认 `Repeatable Read`，这是个非常安全且高效的选择，大多数情况下直接用它就行。PostgreSQL 默认 `Read Committed`，也适用于大部分业务。
3.  **按需提升，而非盲目最高**：不要一开始就想着上 `Serializable`。从你的默认级别开始，如果业务逻辑中出现了不可重复读或幻读导致的问题，再考虑提升到 `Repeatable Read`。只有在 `Repeatable Read` + 锁机制都无法完美解决，且业务可以容忍性能下降时，才去考虑 `Serializable`。
4.  **业务逻辑比隔离级别更重要**：很多并发问题，可以通过优化业务流程、使用乐观锁（版本号机制）或分布式锁来解决，这些手段往往比单纯提升数据库隔离级别带来的副作用要小。

### 总结

事务隔离级别不是一个孤立的技术点，它和你的业务场景、数据库类型、并发模型紧密相关。作为一名 Go 架构师，理解它的原理，并能在实际项目中做出恰当的选择，是构建一个稳定、可靠系统的基本功。希望我从医疗信息系统一线的经验分享，能帮助你更好地理解和运用它。